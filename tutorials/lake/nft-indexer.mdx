---
sidebar_position: 6
sidebar_label: NFT indexer
---

import ProgrammingLanguage from '@site/src/components/ProgrammingLanguage';

# Building an NFT indexer

<ProgrammingLanguage lang="js" />

:::note Source code for the tutorial

[`near-examples/near-lake-nft-indexer`](https://github.com/near-examples/near-lake-nft-indexer): source code for this tutorial

:::

## The End

This tutorial ends with a working NFT indexer built on top [NEAR Lake Framework JS](/docs/projects/near-lake-framework). The indexer is watching for `nft_mint` [Events](https://nomicon.io/Standards/EventsFormat) and prints some relevant data:
- Some `receipt` data of the [Receipt](/docs/data-flow-and-structures/structures/receipt) where the mint has happened
- [Execution status](/docs/data-flow-and-structures/structures/execution_outcome#executionstatusview)
- [Events](https://nomicon.io/Standards/EventsFormat) itself

And additionally:
- Links to the NFT marketplace where you can see the minted token

The final source code is available on the GitHub [`near-examples/near-lake-nft-indexer`](https://github.com/near-examples/near-lake-nft-indexer)

## Motivation

NEAR Protocol had introduced a nice feature [Events](https://nomicon.io/Standards/EventsFormat). The Events allow a contract developer to add standardized logs to the [`ExecutionOutcomes`](/docs/data-flow-and-structures/structures/execution_outcome) thus allowing themselves or other developers to read those logs in more convenient manner via API or indexers.

The Events have a field `standard` which aligns with NEPs. In this tutorial we'll be talking about [NEP-171 Non-Fungible Token standard](https://github.com/near/NEPs/discussions/171).

In this tutorial our goal is to show you how you can "listen" to the Events contracts emit and how you can benefit from them.

As the example we will be building an indexer that watches all the NFTs minted following the NEP-171 standard, assuming we're collectors who don't want to miss a thing. Our indexer should notice every single NFT minted and give us a basic set of data like: in what Receipt it was minted, and show us the link to a marketplace (we'll cover [Paras](https://paras.id) and [Mintbase](https://mintbase.io) for example).

We will use JS version of [NEAR Lake Framework](/docs/projects/near-lake-framework) in this tutorial. Though the concept is the same for Rust, but we want to show more people that it's not that complex to build your own indexer.

## Preparation

:::danger Credentials

Please, ensure you've the credentials set up as described on the [Credentials](./credentials) page. Otherwise you won't be able to get the code working.

:::

You will need:

- `node` [installed and configured](https://nodejs.org/en/download/)

Let's create our project folder

```bash
mkdir lake-nft-indexer && cd lake-nft-indexer
```

Let's add the `package.json`

```json title=package.json
{
  "name": "lake-nft-indexer",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "tsc && node index.js"
  },
  "dependencies": {
    "near-lake-framework": "^1.0.2"
  },
  "devDependencies": {
    "typescript": "^4.6.4"
  }
}
```

You may have noticed we've added `typescript` as a dev dependency. Let's configure the TypeScript. We'll need to create `tsconfig.json` file for that

```json title=tsconfig.json
{
  "compilerOptions": {
    "lib": [
      "ES2019",
      "dom"
    ]
  }
}
```

:::warning ES2019 edition

Please, note the `ES2019` edition used. We require it because we are going to use `.flatMap()` and `.flat()` in our code. These methods were introduces in `ES2019`. Though you can use even more recent

:::

Let's create empty `index.ts` in the project root and thus finish the preparations.

```bash
npm install
```

Now we can start a real work.


## Set up NEAR Lake Framework

In the `index.ts` let's import `startStream` function and `types` from `near-lake-framework`:

```ts title=index.ts
import { startStream, types } from 'near-lake-framework';
```

Add the instantiation of `LakeConfig` below:

```ts title=index.js
const lakeConfig: types.LakeConfig = {
  s3BucketName: "near-lake-data-mainnet",
  s3RegionName: "eu-central-1",
  startBlockHeight: 66264389,
};
```

Just a few words on the config, we have set `s3BucketName` for mainnet, default `s3RegionName` and a fresh-ish block height for `startBlockHeight`. You can go to [NEAR Explorer](https://explorer.near.org) and get **the freshest** block height for your setup. Though you can use the same as we do.

Now we need to create a callback function that we'll be called to handle [`StreamerMessage`](/docs/data-flow-and-structures/structures/toc) our indexer receives.

```ts title=index.ts
async function handleStreamerMessage(
  streamerMessage: types.StreamerMessage
): Promise<void> {

}
```

:::info Callback function requirements

In `near-lake-framework` JS library the handler have to be presented as a callback function. This function have to:
- be asynchronous
- accept an argument of type [`StreamerMessage`](/docs/data-flow-and-structures/structures/toc)
- return nothing (`void`)

:::

And an actual start of our indexer in the end of the `index.ts`

```ts title=index.ts
(async () => {
  await startStream(lakeConfig, handleStreamerMessage);
})();
```

The final `index.ts` at this moment should look like the following:

```ts title=index.ts
import { startStream, types } from 'near-lake-framework';

const lakeConfig: types.LakeConfig = {
  s3BucketName: "near-lake-data-mainnet",
  s3RegionName: "eu-central-1",
  startBlockHeight: 66264389,
};

async function handleStreamerMessage(
  streamerMessage: types.StreamerMessage
): Promise<void> {

}

(async () => {
  await startStream(lakeConfig, handleStreamerMessage);
})();
```


## Events and where to catch them

First of all let's find out where we can catch the Events. We hope you are familiar with how the [Data Flow in NEAR Blockchain](/docs/data-flow-and-structures/flow/near-data-flow), but let's revise our knowledge:
- Mint an NFT is an action in an NFT contract (doesn't matter which one)
- Actions are located in a [Receipt](/docs/data-flow-and-structures/structures/receipt)
- A result of the Receipt execution is [ExecutionOutcome](/docs/data-flow-and-structures/structures/execution_outcome)
- `ExecutionOutcome` in turn, catches the logs a contract "prints"
- [Events](https://nomicon.io/Standards/EventsFormat) built on top of the logs

This leads us to the realization that we can watch only for ExecutionOutcomes and ignore everything else `StreamerMessage` brings us.

Also, we need to define an interface to catch the Events. Let's copy the interface definition from the [Events Nomicon page](https://nomicon.io/Standards/EventsFormat#events) and paste it before the `handleStreamerMessage` function.

```ts title=index.ts
interface EventLogData {
  standard: string,
  version: string,
  event: string,
  data?: unknown,
};
```

## Catching only the data we need

Inside the callback function `handleStreamerMessage` we've prepared in the [Preparation](#preparation) section let's start filtering the data we need:

```ts title=index.ts
async function handleStreamerMessage(
  streamerMessage: types.StreamerMessage
): Promise<void> {
  const relevantOutcomes = streamerMessage
    .shards
    .flatMap(shard => shard.receiptExecutionOutcomes)

}
```

We have iterated through all the [Shards](/docs/data-flow-and-structures/structures/shard) and collected the lists of all ExecutionOutcomes into a single list (in our case we don't care on which Shard did the mint happen)

We want to deal only with those ExecutionOutcomes that contain logs of Events format. Such logs start with `EVENT_JSON:` according to the [Events docs](https://nomicon.io/Standards/EventsFormat#events). Let's filter them as well:

```ts title=index.ts
async function handleStreamerMessage(
  streamerMessage: types.StreamerMessage
): Promise<void> {
  const relevantOutcomes = streamerMessage
    .shards
    .flatMap(shard => shard.receiptExecutionOutcomes)
    .filter(outcome =>
      outcome.executionOutcome.outcome.logs
        .filter(log => log.startsWith("EVENT_JSON:")).length
    )

}
```

Fine, so now we have only a list of ExecutionOutcomes and only those containing the logs that correspond the Events standard.

## Constructing the response data

The goal for our indexer is to return the useful data about a minted NFT:

- Some info about the Receipt: id, receiver and predecessor IDs
- Status of the ExecutionOutcome
- The Event logs

For this goal the entire [ExecutionOutcome](/docs/data-flow-and-structures/structures/execution_outcome) is overloaded, so we need to cut it down to only useful data.

Let's start from a draft:

```ts title=index.ts
  .map(outcome => ({
      receipt: {},
      status: outcome.executionOutcome.outcome.status,
      logs: []
  }))
```

We have populated the status of ExecutionOutcome. Let's populate the Receipt info:

```ts title=index.ts
  .map(outcome => ({
      receipt: {
        id: outcome.receipt.receiptId,
        receiverId: outcome.receipt.receiverId,
        predecessorId: outcome.receipt.predecessorId
      },
      status: outcome.executionOutcome.outcome.status,
      logs: []
  }))
```

Pretty straightforward so far, isn't it?

As for the `logs`, we know that the `EcecutionOutcome.logs` is an array of strings, we need to handle it correspondingly. We want to iterate through all the logs and parse them as `EventLogdata` we've copied from the Events docs.

:::warning Keep in mind

`ExecutionOutcomes.logs` we deal with is an array of strings. And it's not guaranteed that all the elements are Events-compatible. We might have just a string log element.

:::

```ts title=index.ts
    ...
    logs: outcome.executionOutcome.outcome.logs.reduce(
      (events: EventLogData[], log: string): EventLogData[] => {
        const probablyEvent = log.split("EVENT_JSON:")[1]
        try {
          const event: EventLogData = JSON.parse(probablyEvent)
          events.push(event)
        } catch (e) {
          // pass
        }
        return events
      }, [])
    }))
    ...
```

Here we try to split the logs string by `EVENT_JSON:` and take only the second part. Next, we are trying to parse the JSON as `EventLogData` and return it.

The `probablyEvent` constant might be invalid or even `undefined`, and we want to ignore those in order to have an array of only `EventLogData` as a result. That's why we use `.reduce()` here.

OK, so far we have to have the following code in our `handleStreamerMessage` function:

```ts title=index.ts
async function handleStreamerMessage(
  streamerMessage: types.StreamerMessage
): Promise<void> {
  const relevantOutcomes = streamerMessage
    .shards
    .flatMap(shard => shard.receiptExecutionOutcomes)
    .filter(outcome =>
      outcome.executionOutcome.outcome.logs
        .filter(log => log.startsWith("EVENT_JSON:")).length
    )
    .map(outcome => ({
      receipt: {
        id: outcome.receipt.receiptId,
        receiverId: outcome.receipt.receiverId,
        predecessorId: outcome.receipt.predecessorId,
      },
      status: outcome.executionOutcome.outcome.status,
      logs: outcome.executionOutcome.outcome.logs.reduce(
        (events: EventLogData[], log: string): EventLogData[] => {
          const probablyEvent = log.split("EVENT_JSON:")[1]
          try {
            const event: EventLogData = JSON.parse(probablyEvent)
            events.push(event)
          } catch (e) {
            // pass
          }
          return events
        }, []
      )
    }))

}
````

Let's filter the data again by cutting down the outcomes that don't follow the `nep171` standard along with all events except `nft_mint`:

```ts title=index.ts
  ...
  .filter(relevantOutcome =>
    relevantOutcome.logs.filter(
      log =>  log.standard === "nep171" && log.event === "nft_mint"
    ).length
  )
  ...
```

## Almost done

So far we have collected everything we need corresponding to our requirements.

We can print everything in the end of the `handleStreamerMessage`:

```ts title=index.ts
  relevantOutcomes.length && console.dir(relevantOutcomes, { depth: 10 })
```

The final look of the `handleStreamerMessage` function:

```ts title=index.ts
async function handleStreamerMessage(
  streamerMessage: types.StreamerMessage
): Promise<void> {
  const relevantOutcomes = streamerMessage
    .shards
    .flatMap(shard => shard.receiptExecutionOutcomes)
    .filter(outcome =>
      outcome.executionOutcome.outcome.logs
        .filter(log => log.startsWith("EVENT_JSON:")).length
    )
    .map(outcome => ({
      receipt: {
        id: outcome.receipt.receiptId,
        receiverId: outcome.receipt.receiverId,
        predecessorId: outcome.receipt.predecessorId,
      },
      status: outcome.executionOutcome.outcome.status,
      logs: outcome.executionOutcome.outcome.logs.reduce(
        (events: EventLogData[], log: string): EventLogData[] => {
          const probablyEvent = log.split("EVENT_JSON:")[1]
          try {
            const event: EventLogData = JSON.parse(probablyEvent)
            events.push(event)
          } catch (e) {
            // pass
          }
          return events
        }, []
       )
    }))
    .filter(relevantOutcome =>
      relevantOutcome.logs.filter(
        log =>  log.standard === "nep171" && log.event === "nft_mint"
      ).length
    )

  relevantOutcomes.length && console.dir(relevantOutcomes, { depth: 10 })
}

```

And if we run our indexer we will be catching `nft_mint` event and print the data in the terminal.

```bash
npm run start
```

:::note

Having troubles running the indexer? Please, check you haven't skipped the [Credentials](./credentials) part :)

:::

Not so fast! Remember we were talking about having the links to the marketplaces to see the minted tokens? We're gonna extend our data with links whenever possible. At least we're gonna show you how to deal with the NFTs minted on [Paras](https://paras.id) and [Mintbase](https://mintbase.io).

## Crafting links to Paras and Mintbase for NFTs minted there

At this moment we have an array of objects we've crafted on the fly that exposes receipt, execution status and event logs. We definitely know that all the data we have at this moment are relevant for us, and we want to extend it with the links to that minted NFTs at least for those marketplaces we know.

We know and love Paras and Mintbase.

### Paras token URL

We did the research for you and here's how the URL to token on Paras is crafting:

```
https://paras.id/token/[1]::[2]/[3]
```

Where:

[1] - Paras contract address (`x.paras.near`)
[2] - First part of the `token_id` (`EventLogData.data` for Paras is an array of objects with `token_ids` key in it. Those IDs represented by numbers with column `:` between them)
[3] - `token_id` itself

Example:

```
https://paras.id/token/x.paras.near::387427/387427:373
```

Let's add the interface for later use somewhere after `interface EventLogData`:

```ts
interface ParasEventLogData {
  token_ids: string[],
};
```

### Mintbase token URL

And again we did the research for you:

```
https://www.mintbase.io/thing/[1]:[2]
```

Where:

[1] - `meta_id` (`EventLogData.data` for Mintbase is an array of stringified JSON that contains `meta_id`)
[2] - Store contract account address (basically Receipt's receiver ID)

Example:

```
https://www.mintbase.io/thing/70eES-icwSw9iPIkUluMHOV055pKTTgQgTiXtwy3Xus:vnartistsdao.mintbase1.near
```

Let's add the interface for later use somewhere after `interface EventLogData`:

```ts
interface MintbaseEventLogData {
  memo: string,
}
```

Not it's a perfect time to add another `.map()` to the data we have collected. We will extend the data objects with `links` field with actually the links:

```ts title=index.ts
  .map(relevantOutcome => {
    return {
      ...relevantOutcome,
      links: relevantOutcome.logs.maps(event => {

      }).flat()
    }
  })
```

Note, we have added `.flat()`, it's because we don't want to have an array of arrays.

Let's start crafting the links, Time to say "Hi!" to [Riqi](https://twitter.com/hdriqi) (just because we can):

```ts title=index.ts
  .map(relevantOutcome => {
    return {
      ...relevantOutcome,
      links: relevantOutcome.logs.maps(event => {
        if (relevantOutcome.receipt.receiverId.includes(".paras")) {
          return (event.data as ParasEventLogData[]).map(data =>
            data.token_ids.map(
              tokenId => `https://paras.id/token/${relevantOutcome.receipt.receiverId}::${tokenId.split(":")[0]}/${tokenId}`
            ).flat()
          ).flat()
        } else if () {

        }
      }).flat()
    }
  })
```

:::note

Checkout how we have used `ParasEventLogData` we have defined earlier.

:::

Mintbase turn, we hope [Nate](https://twitter.com/nategeier) and his team have migrated to NEAR Lake Framework already, saying "Hi!" and crafting the link:

```ts title=index.ts
  ...
        } else if (relevantOutcome.receipt.receiverId.includes(".mintbase")) {
          return (event.data as MintbaseEventLogData[]).map(data => {
            const memo = JSON.parse(data.memo)
            return `https://mintbase.io/thing/${memo["meta_id"]}:${relevantOutcome.receipt.receiverId}`
          })
        }
      }).flat()
    }
  })
```

And if we can't determine the marketplace:

```ts title=index.ts
        } else {
          return []
        }
```

All together:

```ts title=index.ts
  .map(relevantOutcome => {
    return {
      ...relevantOutcome,
      links: relevantOutcome.logs.map(event => {
        if (relevantOutcome.receipt.receiverId.includes(".paras")) {
          return (event.data as ParasEventLogData[]).map(data =>
            data.token_ids.map(
              tokenId => `https://paras.id/token/${relevantOutcome.receipt.receiverId}::${tokenId.split(":")[0]}/${tokenId}`
            ).flat()
          ).flat()
        } else if (relevantOutcome.receipt.receiverId.includes(".mintbase")) {
          return (event.data as MintbaseEventLogData[]).map(data => {
            const memo = JSON.parse(data.memo)
            return `https://mintbase.io/thing/${memo["meta_id"]}:${relevantOutcome.receipt.receiverId}`
          })
        } else {
          return []
        }
      }).flat()
    }
  })
```

And not that's it. Run the indexer to watch for NFT minting and never miss a thing.

```bash
npm run start
```

:::note

Having troubles running the indexer? Please, check you haven't skipped the [Credentials](./credentials) part :)

:::

Example output:

```
[
  {
    receipt: {
      id: '4RswuUv9mK7amJjgCPKX71W6eAa81g1z3in7xrF6SfbB',
      receiverId: 'x.paras.near',
      predecessorId: 'chubbless.near'
    },
    status: { SuccessValue: 'IjM5ODA0MzoxIg==' },
    logs: [
      {
        standard: 'nep171',
        version: '1.0.0',
        event: 'nft_mint',
        data: [ { owner_id: 'chubbless.near', token_ids: [ '398043:1' ] } ]
      }
    ],
    links: [ 'https://paras.id/token/x.paras.near::398043/398043:1' ]
  }
]
[
  {
    receipt: {
      id: '7ayNpevmRBCgetns2q1j4L4R7qmB5dDYguYjxc7VijAW',
      receiverId: 'vnartistsdao.mintbase1.near',
      predecessorId: 'fcliver.near'
    },
    status: { SuccessValue: '' },
    logs: [
      {
        standard: 'nep171',
        version: '1.0.0',
        event: 'nft_mint',
        data: [
          {
            owner_id: 'fcliver.near',
            token_ids: [ '202' ],
            memo: '{"royalty":{"split_between":{"vn-artists-dao.near":{"numerator":10000}},"percentage":{"numerator":1500}},"split_owners":null,"meta_id":"70eES-icwSw9iPIkUluMHOV055pKTTgQgTiXtwy3Xus","meta_extra":null,"minter":"fcliver.near"}'
          }
        ]
      }
    ],
    links: [
      'https://mintbase.io/thing/70eES-icwSw9iPIkUluMHOV055pKTTgQgTiXtwy3Xus:vnartistsdao.mintbase1.near'
    ]
  }
]
```

## Conclusion

What a ride, yeah? Let's sum up what we have done:

- You've learnt about [Events](https://nomicon.io/Standards/EventsFormat)
- Now you understand how to follow for the Events
- Knowing the fact that as a contract developer you can use Events and emit your own events, now you know how to create an indexer that follows those Events
- We've had a closer look at NFT minting process, you can experiment further and find out how to follow `nft_transfer` Events

The material from this tutorial can be extrapolated for literally any event that follows the [Events format](https://nomicon.io/Standards/EventsFormat)

Not mentioning you have a dedicated indexer to find out about the newest NFTs minted out there and to be the earliest bird to collect them.

Let's go hunt doo, doo, doo ðŸ¦ˆ

:::note Source code for the tutorial

[`near-examples/near-lake-nft-indexer`](https://github.com/near-examples/near-lake-nft-indexer): source code for this tutorial

:::
